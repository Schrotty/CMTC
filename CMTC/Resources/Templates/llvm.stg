file(symbols) ::= <<
<symbols>
>>

// variable templates
symbol(symbol) ::= <<
<if(symbol.GlobalSymbol)>@<symbol.Name><else>%<symbol.Position><endif>
>>

symbolDeclaration(symbol) ::= <<
<if(symbol.GlobalSymbol)><globalSymbolDeclaration(symbol)>
<else><localSymbolDeclaration(symbol)><endif>
>>

globalSymbolDeclaration(symbol) ::= <<
<symbol(symbol)> = common global <typeMap.(symbol.Type)> <typeDefaultValues.(symbol.Type)>
>>

localSymbolDeclaration(symbol) ::= <<
<symbol(symbol)> = alloca <typeMap.(symbol.Type)>
>>

// function templates
function(function, block) ::= <<
define <typeMap.(function.Type)> @<function.Name>(<parameterList(function.Parameter)>)
{
	<block>
}
>>

parameterList(parameter) ::= <<
<trunc(parameter):parameter()><typeMap.(last(parameter))>
>>

parameter(parameter) ::= <<
<typeMap.(parameter)>, 
>>

// statement & expression templates
statement(statement) ::= <<
<statement>
>>

expression(expr) ::= <<
<expr>
>>

returnStatement(symbol) ::= <<
ret <typeMap.(symbol.Type)> <symbol(symbol)>
>>

methodCallExpr(symbol, method) ::= <<
<symbol(symbol)> = call <typeMap.(method.Type)> @<method.Name>(<method.Parameter>)
>>

args(parameter) ::= "<trunc(parameter):arg()><typeMap.(last(parameter))>"
arg(type) ::= "<typeMap.(type)>, "

addSubExpr(op, target, one, two) ::= <<
<symbol(target)> = <opMap.(op)> <typeMap.(target.Type)> <symbol(one)>, <symbol(two)>
>>

storeStat(target, source) ::= <<
store <typeMap.(target.Type)> <source>, <typeMap.(target.Type)>* <symbol(target)>
>>

assignStat(target, source) ::= <<
<symbol(target)> = load <typeMap.(target.Type)>, <typeMap.(target.Type)>* <symbol(source)>
>>

// ops & type maps
opMap ::= [
	"+":"add",
	"-":"sub"
]

typeMap ::= [
	"INT":"i32",
	"VOID":"void"
]

typeDefaultValues ::= [
	"INT":"0"
]