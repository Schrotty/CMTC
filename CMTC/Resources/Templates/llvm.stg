file(functionDecls, variableDecls) ::= <<
<variableDecls>
<functionDecls>
>>

// variable templates
symbol(symbol) ::= <<
<if(symbol.GlobalSymbol)>@<symbol.Name><else>%<symbol.Position><endif>
>>

symbolDeclaration(symbol) ::= <<
<if(symbol.GlobalSymbol)><globalSymbolDeclaration(symbol)><else><localSymbolDeclaration(symbol)><endif>
>>

globalSymbolDeclaration(symbol) ::= <<
<symbol(symbol)> = common global <typeMap.(symbol.Type)> <typeDefaultValues.(symbol.Type)>
>>

localSymbolDeclaration(symbol) ::= <<
<symbol(symbol)> = alloca <typeMap.(symbol.Type)>
>>

functionDecl(returnType, identifier, parameter, block) ::= <<
	define <typeMap.(returnType)> @<identifier>(<parameter>)
	<block>
>>

formalParameters(parameter) ::= "<trunc(parameter):formalParameterItem()><typeMap.(last(parameter))>"
formalParameterItem(type) ::= "<typeMap.(type)>, "

statement(statement) ::= <<
	<statement>
>>

expression(expr) ::= <<
	<expr>

>>

block(statement) ::= <<
{
	<statement>
}

>>

assignStat() ::= <<
	
>>

returnStatement(type, result, expr) ::= <<
	<expr>

	ret <typeMap.(type)> %<result>
>>

methodCallExpr(index, id, type, args) ::= <<
	%<index> = call <typeMap.(type)> @<id>(<args>)

>>

args(parameter) ::= "<trunc(parameter):arg()><typeMap.(last(parameter))>"
arg(type) ::= "<typeMap.(type)>, "

addSubExpr(index, type, op, op1, op2) ::= <<
	%<index> = <opMap.(op)> <typeMap.(type)> %<op1>, %<op2>

>>

storeValue(type, source, target) ::= <<
	store <typeMap.(type)> <source>, <typeMap.(type)>* %<target>

>>

loadValue(target, type, source, globalSource) ::= <<
	%<target> = load <typeMap.(type)>, <typeMap.(type)>* <if(globalSource)>@<else>%<endif><source>

>>

int(value) ::= "<value>"

opMap ::= [
	"+":"add",
	"-":"sub"
]

typeMap ::= [
	"INT":"i32",
	"VOID":"void"
]

typeDefaultValues ::= [
	"INT":"0"
]